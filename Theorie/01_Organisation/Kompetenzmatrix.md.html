<meta charset="utf-8" emacsmode="-*- markdown -*-">
<link rel="stylesheet" href="https://casual-effects.com/markdeep/latest/apidoc.css?"">
<style class="fallback">body{visibility:hidden}</style><script>markdeepOptions={tocStyle:'medium'};</script>
<!-- Markdeep: --><script src="https://casual-effects.com/markdeep/latest/markdeep.min.js?" charset="utf-8"></script>

# Kompetenzmatrix Modul 323

| Kompetenzband: | HZ | Grundlagen | Fortgeschritten | Erweitert |
| ------------------------------------------------------------------------------------------------ | -- | ---------- | --------------- | --------- |
| Unterschiede zwischen funktionaler Programmierung und<br/>anderen Programmierparadigmen aufzeigen. | 1 | AG1:<br/> Ich kann die Eigenschaften von Funktionen beschreiben (z.Bsp. pure function) und den Unterschied zu anderen Programmier-Strukturen erläutern (z.Bsp. zu Prozedur).| AF1:<br/> Ich kann das Konzept von *immutable values* erläutern und dazu Beispiele anwenden. Somit kann ich dieses Konzept funktionaler Programmierung im Unterschied zu anderen Programmiersprachen erklären (z.Bsp. im Vergleich zu referenzierten Objekten)| AE1:<br/> Ich kann aufzeigen wie Probleme in den verschiedenen Konzepten (OO, prozedural und funktional) gelöst werden und diese miteinander vergleichen.|
| Anforderungen und Design beschreiben  | 1 | BG1:<br/>Ich kann den Unterschied zwischen Anforderungen der imperativen Programmierung (definierte Folge von Handlungsanweisungen) und der deklarativen Programmierung (Beschreibung des Endzustandes) erklären.| BF1:<br/>Ich kann den Endzustand als Anforderung im Sinne der deklarativen Programmierung beschreiben. (Das gewünschte Ergebnis wird beschrieben statt die Arbeitsschritte.)| BE1:<br/>Ich kann Anforderungen aus der imperativen Programmierung in Anforderungen der deklarativen Programmierung transferieren. ("klar definierte Abfolge" transformieren zu "Endergebnis beschreiben")|
|  |  | BG2:<br/>Ich kann Elemente des Functional Design erklären. (zBsp. Immutable data types, model, solution, domain of interest, constructors, composable operators)| BF2:<br/>Ich kann für eine Problemstellung ein Functional-Design entwerfen und dabei die Elemente des Functional Designs anwenden.| BE2:<br/>Ich kann ein Design einer imperativen Programmierung in ein Desing der deklarativen Programmierung transferieren.|
| Funktionale Programmierung umsetzen | 2 | C1G:<br/>Ich kann ein Algorithmus erklären | C1F:<br/>Ich kann Algorithmen in funktionale Teilstücke aufteilen | C1E:<br/>Ich kann Funktionen in zusammenhängende Algorithmen implementieren |
| | | C2G:<br/>Ich kann Funktionen als Objekte behandeln und diese in Variablen speichern und weitergeben. | C2F:<br/>Ich kann Funktionen als Argumente für andere Funktionen verwenden und dadurch höherwertige Funktionen erstellen.| C2E:<br/>Ich kann Funktionen als Objekte und Argumente verwenden, um komplexe Aufgaben zu lösen und den Code sauberer und effizienter zu gestalten. |
|  |  | C3G:<br/>Ich kann einfache Lambda-Ausdrücke schreiben, die eine einzelne Operation durchführen, z.B. das Quadrieren einer Zahl oder das Konvertieren eines Strings in Großbuchstaben. | C3F:<br/>Ich kann Lambda-Ausdrücke schreiben, die mehrere Argumente verarbeiten können. | C3E:<br/>Ich kann Lambda-Ausdrücke verwenden, um den Programmfluss zu steuern, z.B. durch Sortieren von Listen basierend auf benutzerdefinierten Kriterien. |
|  |  | C4G:<br/>Ich kann die Funktionen Map, Filter und Reduce einzeln auf Listen anwenden. | C4F:<br/>1.  Ich kann Map, Filter und Reduce kombiniert verwenden, um Daten zu verarbeiten und zu manipulieren, die komplexere Transformationen erfordern. | C4E:<br/>1.  Ich kann Map, Filter und Reduce verwenden, um komplexe Datenverarbeitungsaufgaben zu lösen, wie z.B. die Aggregation von Daten oder die Transformation von Datenstrukturen. |
| Refactoring und bestehenden Code optimieren |  3,4| DG1:Ich kann einige Refactoring-Techniken aufzählen, die einen Code lesbarer und verständlicher machen.  | DF1:Ich kann mit Refactoring-Techniken einen Code lesbarer und verständlicher machen.  | DE1:Ich kann die Auswirkungen des Refactorings auf das Verhalten des Codes einschätzen und sicherstellen, dass das Refactoring keine unerwünschten Nebenef-fekte hat.  |
|  |  | DG2: Ich kann allgemeine Massnahmen zur Verbesserung der Leis-tung von Code aufzählen.|  DF2:Ich kann vorgegebene Massnah-men zur Verbesserung der Leistung von Code umsetzen.|  DE2: Ich kann effiziente Algorithmen, Techniken oder Datenstrukturen auswählen und einsetzen, um die Leistung von Code zu ver-bessern.| 

## Kompetenzstufen

### Grundlagen | Der Anfänger | Stufe 1

Diese Stufe ist als Einstieg ins Thema gedacht. Der Fokus liegt hier auf dem Verstehen von Begriffen und Zusammenhängen.

*Als Richtungshinweis: Wer alle Kompetenzen in dieser Stufe erfüllt, hat die Noten 3.5.*

### Fortgeschritten | Der Kompetente | Stufe 2

Diese Stufe definiert den Pflichtstoff, den alle Lernenden am Ende des Moduls möglichst beherrschen sollen.

*Als Richtungshinweis: Wer alle Kompetenzen in dieser Stufe erfüllt, hat die Noten 4.75*

### Erweitert | Der Gewandete | Stufe 3

Diese Lerninhalte für Lernende gedacht, die schneller vorankommen und einen zusätzlichen Lernanreiz erhalten sollen.

*Als Richtungshinweis: Wer alle Kompetenzen in dieser Stufe erfüllt, hat die Noten 6*

